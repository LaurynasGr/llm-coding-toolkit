import { parseArgs } from 'node:util';
import { execFileSync } from 'node:child_process';
import { mkdir, readFile, writeFile } from 'node:fs/promises';
import { basename, join } from 'node:path';
import { homedir } from 'node:os';
import { intro, outro } from '@clack/prompts';
import pc from 'picocolors';
import { log } from '../utils/index.ts';
import { COMMANDS, FLAGS, GLOBAL_FLAGS, SUBCOMMANDS } from '../commands.ts';

const BEGIN_MARKER = '# >>> llmct autocomplete >>>';
const END_MARKER = '# <<< llmct autocomplete <<<';

function isCommandAvailable(cmd: string): boolean {
  try {
    const shell = process.env.SHELL || 'sh';
    execFileSync(shell, ['-ic', 'command -v -- "$1"', '_', cmd], { stdio: 'ignore' });
    return true;
  } catch {
    return false;
  }
}

type SupportedShell = 'zsh' | 'bash' | 'fish';

function getCurrentShell(): SupportedShell | null {
  const shellPath = process.env.SHELL;
  if (!shellPath) return null;

  const shell = basename(shellPath);
  if (shell === 'zsh' || shell === 'bash' || shell === 'fish') {
    return shell;
  }

  return null;
}

function buildBashOrZshSnippet(shell: 'bash' | 'zsh'): string {
  const names = [...Object.keys(COMMANDS), ...Object.keys(GLOBAL_FLAGS)];
  const targets = ['llmct', ...(isCommandAvailable('llmct-dev') ? ['llmct-dev'] : [])].join(' ');

  if (shell === 'zsh') {
    const zshEntries = Object.entries({ ...COMMANDS, ...GLOBAL_FLAGS })
      .map(([name, desc]) => `    '${name}:${desc}'`)
      .join('\n');

    const zshSubcommandCases = Object.entries(SUBCOMMANDS)
      .map(([cmd, subs]) => {
        const entries = Object.entries(subs)
          .map(([name, desc]) => `        '${name}:${desc}'`)
          .join('\n');
        return `    ${cmd})\n      local -a subcommands\n      subcommands=(\n${entries}\n      )\n      _describe 'subcommand' subcommands\n      ;;`;
      })
      .join('\n');

    return `${BEGIN_MARKER}
if ! typeset -f compdef >/dev/null 2>&1; then
  autoload -Uz compinit
  compinit
fi

_llmct_completions() {
  local -a commands
  commands=(
${zshEntries}
  )

  if (( CURRENT == 2 )); then
    _describe 'command' commands
  elif (( CURRENT == 3 )); then
    case "${'$'}{words[2]}" in
${zshSubcommandCases}
    esac
  fi
}
${targets.includes('llmct-dev') ? '\nsetopt localoptions COMPLETE_ALIASES' : ''}
compdef _llmct_completions ${targets}
${END_MARKER}
`;
  }

  const subcommandBashCases = Object.entries(SUBCOMMANDS)
    .map(([cmd, subs]) => {
      const subNames = Object.keys(subs).join(' ');
      return `      ${cmd}) COMPREPLY=( ${'$'}(compgen -W '${subNames}' -- "${'$'}cur") ) ;;`;
    })
    .join('\n');

  return `${BEGIN_MARKER}
_llmct_completions() {
  local cur prev
  cur="${'$'}{COMP_WORDS[COMP_CWORD]}"
  prev="${'$'}{COMP_WORDS[COMP_CWORD-1]}"

  if [[ ${'$'}COMP_CWORD -eq 1 ]]; then
    COMPREPLY=( ${'$'}(compgen -W '${names.join(' ')}' -- "${'$'}cur") )
  elif [[ ${'$'}COMP_CWORD -eq 2 ]]; then
    case "${'$'}prev" in
${subcommandBashCases}
    esac
  fi
}

complete -F _llmct_completions ${targets}
${END_MARKER}
`;
}

function buildFishSnippet(): string {
  const commands = Object.keys(COMMANDS).join(' ');
  const globalFlags = FLAGS.flatMap(({ name, short, description }) => {
    const lines = [`complete -c llmct -n "__fish_use_subcommand" -l ${name.slice(2)} -d "${description}"`];

    if (short) {
      lines.push(`complete -c llmct -n "__fish_use_subcommand" -s ${short.slice(1)} -d "${description}"`);
    }

    return lines;
  }).join('\n');

  const subcommandCompletions = Object.entries(SUBCOMMANDS)
    .flatMap(([cmd, subs]) =>
      Object.entries(subs).map(
        ([name, desc]) => `complete -c llmct -n "__fish_seen_subcommand_from ${cmd}" -a "${name}" -d "${desc}"`,
      ),
    )
    .join('\n');

  return `# Generated by llmct autocomplete
complete -c llmct -f
complete -c llmct -n "__fish_use_subcommand" -a "${commands}"
${globalFlags}
${subcommandCompletions}
`;
}

async function upsertMarkedBlock(filePath: string, block: string): Promise<boolean> {
  let current = '';

  try {
    current = await readFile(filePath, 'utf-8');
  } catch {
    // file doesn't exist yet
  }

  const escapeRegex = (s: string) => s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  const MARKER_REGEX = new RegExp(`${escapeRegex(BEGIN_MARKER)}[\\s\\S]*?${escapeRegex(END_MARKER)}\\n?`, 'g');

  const cleaned = current.replace(MARKER_REGEX, '').trimEnd();
  const next = `${cleaned}${cleaned ? '\n\n' : ''}${block}`;

  if (current === next) {
    return false;
  }

  await writeFile(filePath, next);
  return true;
}

export async function autocomplete(args: string[]) {
  const { values } = parseArgs({
    args,
    options: {
      help: { type: 'boolean', short: 'h' },
    },
  });

  if (values.help) {
    console.log(`Usage: ${pc.bold('llmct autocomplete')}

Install shell autocomplete for llmct on the current system shell.

Options:
  ${pc.bold('-h, --help')}               Show this help message`);
    process.exit(0);
  }

  const shell = getCurrentShell();

  if (!shell) {
    log.error([
      `Unsupported or undetected shell: ${pc.bold(process.env.SHELL ?? 'unknown')}`,
      'Supported shells: zsh, bash, fish',
    ]);
    process.exit(1);
  }

  intro(pc.bold(`Autocomplete Setup (${shell})`));

  if (shell === 'fish') {
    const fishDir = join(homedir(), '.config', 'fish', 'completions');
    const filePath = join(fishDir, 'llmct.fish');
    await mkdir(fishDir, { recursive: true });
    await writeFile(filePath, buildFishSnippet());
    log.success(`Written fish completion to ${pc.bold(filePath)}`);
    outro(pc.green('Done. Open a new shell session to use autocomplete.'));
    return;
  }

  const rcFileName = shell === 'zsh' ? '.zshrc' : '.bashrc';
  const rcPath = join(homedir(), rcFileName);
  const changed = await upsertMarkedBlock(rcPath, buildBashOrZshSnippet(shell));

  if (changed) {
    log.success(`Updated ${pc.bold(rcPath)} with llmct autocomplete.`);
  } else {
    log.info(`Autocomplete is already configured in ${pc.bold(rcPath)}.`);
  }

  outro(pc.green(`Done. Restart your shell or run: source ${rcPath}`));
}
