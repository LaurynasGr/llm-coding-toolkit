import { parseArgs } from 'node:util';
import { execFileSync } from 'node:child_process';
import { mkdir, readFile, writeFile } from 'node:fs/promises';
import { basename, join } from 'node:path';
import { homedir } from 'node:os';
import { intro, outro } from '@clack/prompts';
import pc from 'picocolors';
import { log } from '../utils/index.ts';
import { COMMANDS } from '../commands.ts';

const BEGIN_MARKER = '# >>> llmct autocomplete >>>';
const END_MARKER = '# <<< llmct autocomplete <<<';

function isCommandAvailable(cmd: string): boolean {
  try {
    const shell = process.env.SHELL || 'sh';
    execFileSync(shell, ['-ic', 'command -v -- "$1"', '_', cmd], { stdio: 'ignore' });
    return true;
  } catch {
    return false;
  }
}

type SupportedShell = 'zsh' | 'bash' | 'fish';

function getCurrentShell(): SupportedShell | null {
  const shellPath = process.env.SHELL;
  if (!shellPath) return null;

  const shell = basename(shellPath);
  if (shell === 'zsh' || shell === 'bash' || shell === 'fish') {
    return shell;
  }

  return null;
}

const FLAGS = [
  { name: '--help', short: '-h', description: 'Show help message' },
  { name: '--version', short: '-v', description: 'Show version number' },
] as const satisfies { name: string; short?: string; description: string }[];

const GLOBAL_FLAGS = Object.fromEntries(
  FLAGS.flatMap(({ name, short, description }) =>
    short
      ? [
          [name, description],
          [short, description],
        ]
      : [[name, description]],
  ),
);

function buildBashOrZshSnippet(shell: 'bash' | 'zsh'): string {
  const names = [...Object.keys(COMMANDS), ...Object.keys(GLOBAL_FLAGS)];
  const targets = ['llmct', ...(isCommandAvailable('llmct-dev') ? ['llmct-dev'] : [])].join(' ');

  if (shell === 'zsh') {
    const zshEntries = Object.entries({ ...COMMANDS, ...GLOBAL_FLAGS })
      .map(([name, desc]) => `    '${name}:${desc}'`)
      .join('\n');

    return `${BEGIN_MARKER}
if ! typeset -f compdef >/dev/null 2>&1; then
  autoload -Uz compinit
  compinit
fi

setopt COMPLETE_ALIASES

_llmct_completions() {
  local -a commands
  commands=(
${zshEntries}
  )

  if (( CURRENT == 2 )); then
    _describe 'command' commands
  fi
}

compdef _llmct_completions ${targets}
${END_MARKER}
`;
  }

  return `${BEGIN_MARKER}
_llmct_completions() {
  local cur
  cur="${'$'}{COMP_WORDS[COMP_CWORD]}"

  if [[ ${'$'}COMP_CWORD -eq 1 ]]; then
    COMPREPLY=( ${'$'}(compgen -W '${names.join(' ')}' -- "${'$'}cur") )
  fi
}

complete -F _llmct_completions ${targets}
${END_MARKER}
`;
}

function buildFishSnippet(): string {
  const commands = Object.keys(COMMANDS).join(' ');
  const globalFlags = FLAGS.flatMap(({ name, short, description }) => {
    const lines = [`complete -c llmct -n "__fish_use_subcommand" -l ${name.slice(2)} -d "${description}"`];

    if (short) {
      lines.push(`complete -c llmct -n "__fish_use_subcommand" -s ${short.slice(1)} -d "${description}"`);
    }

    return lines;
  }).join('\n');

  return `# Generated by llmct autocomplete
complete -c llmct -f
complete -c llmct -n "__fish_use_subcommand" -a "${commands}"
${globalFlags}
`;
}

async function upsertMarkedBlock(filePath: string, block: string): Promise<boolean> {
  let current = '';

  try {
    current = await readFile(filePath, 'utf-8');
  } catch {
    // file doesn't exist yet
  }

  const escapedBegin = BEGIN_MARKER.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  const escapedEnd = END_MARKER.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  const markerRegex = new RegExp(`${escapedBegin}[\\s\\S]*?${escapedEnd}\\n?`, 'g');
  const cleaned = current.replace(markerRegex, '').trimEnd();
  const next = `${cleaned}${cleaned ? '\n\n' : ''}${block}`;

  if (current === next) {
    return false;
  }

  await writeFile(filePath, next);
  return true;
}

export async function autocomplete(args: string[]) {
  const { values } = parseArgs({
    args,
    options: {
      help: { type: 'boolean', short: 'h' },
    },
  });

  if (values.help) {
    console.log(`Usage: ${pc.bold('llmct autocomplete')}

Create shell autocomplete for llmct on the current system shell.

Options:
  ${pc.bold('-h, --help')}               Show this help message`);
    process.exit(0);
  }

  const shell = getCurrentShell();

  if (!shell) {
    log.error([
      `Unsupported or undetected shell: ${pc.bold(process.env.SHELL ?? 'unknown')}`,
      'Supported shells: zsh, bash, fish',
    ]);
    process.exit(1);
  }

  intro(pc.bold(`Autocomplete Setup (${shell})`));

  if (shell === 'fish') {
    const fishDir = join(homedir(), '.config', 'fish', 'completions');
    const filePath = join(fishDir, 'llmct.fish');
    await mkdir(fishDir, { recursive: true });
    await writeFile(filePath, buildFishSnippet());
    log.success(`Written fish completion to ${pc.bold(filePath)}`);
    outro(pc.green('Done. Open a new shell session to use autocomplete.'));
    return;
  }

  const rcFileName = shell === 'zsh' ? '.zshrc' : '.bashrc';
  const rcPath = join(homedir(), rcFileName);
  const changed = await upsertMarkedBlock(rcPath, buildBashOrZshSnippet(shell));

  if (changed) {
    log.success(`Updated ${pc.bold(rcPath)} with llmct autocomplete.`);
  } else {
    log.info(`Autocomplete is already configured in ${pc.bold(rcPath)}.`);
  }

  outro(pc.green('Done. Restart your shell or run: source ' + rcPath));
}
